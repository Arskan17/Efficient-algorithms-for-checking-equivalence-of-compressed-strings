from itertools import combinations # https://docs.python.org/3/library/itertools.html#itertools.combinations
import input
import sys

def compute_all_pairs(grammar):
    nonterminals = set(grammar.keys())  # Collect all nonterminals
    S = set(combinations(nonterminals, 2))  # Generate all pairs
    return S

def compute_lengths(grammar):
    lengths = {}

    def get_length(symbol):
        if symbol in lengths:  # Memoization
            return lengths[symbol]
        if symbol not in grammar:  # Base case (it's a terminal)
            return 1
        lengths[symbol] = sum(get_length(s) for s in grammar[symbol])  # Recursive sum
        return lengths[symbol]

    for nonterminal in grammar:
        get_length(nonterminal)  # Compute length for each nonterminal

    return lengths

def check_lengths(S, lengths):
    checks = [lengths[pair[0]] == lengths[pair[1]] for pair in S]
    return all(checks)

def compute_descending_nonterminals(lengths):
    desc_nonterminals = sorted(lengths, key=lengths.get, reverse=True) # sort nonterminals in descending order according to |w_A|
    return desc_nonterminals


if __name__ == '__main__':
    # input
    grammar = input.G # grammar G which defines a set of words
    S = compute_all_pairs(grammar) # set S of pairs of nonterminals from G
    print(f'set S = {S}')


    # output
    ############################################################################################################
    # compute lengths of words generated by nonterminals in G and check if for each (A, B) in S w_A = w_B
    ############################################################################################################


    # begin
    lengths = compute_lengths(grammar) # compute |w_A| for each nonterminal A
    # print(lengths)
    if not check_lengths(S, lengths): # if there is (A, B) in S such that |w_A| != |w_B| then return false
        sys.exit(False)

    desc_nonterminals = compute_descending_nonterminals(lengths) # ( A_1, ..., A_n)
    print(desc_nonterminals)